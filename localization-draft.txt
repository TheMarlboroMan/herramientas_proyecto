#key[:text:]
#(:variable:)
#<:embed:>

textkey[:Whatever is before the colon pair would be the key name. Whatever follows 
the colon is the text that the app will display. We could use variable 
substitution in some easy to parse way, (:varname:) and we should denote the
end of the string with something easy too, like the separator.:]

#Whatever goes here should be a comment.

	whitespace[:whitespace is ignored when reading a key.:]

This would be a syntax error.

anothertextkey[:This is another thing (:varname:), (:varname2:). Text after the
separator is discarded:] This would be discarded

yetanother[:This is another text... An idea could be to embed other texts
using yet another separator type, say <:embed:>. Of course, embedding would
need to keep an eye on recursivity:]

#The same key should not be repeated.
#
#The parser would be easy, with three modes: "Outside", "key" and "value".
#Outside mode
#
#	this is the default mode.
#	any line beginning with # is a comment.
#	any empty (trimmed) line is ignored.
#	end of file ends the parsing.
#	read into the buffer:
#		any whitespace is ignored.
#		anything else begins reading a key.
#Key mode:
#	
#	end of file is a syntax error
#	read into the buffer:
#		anything we read is a key character.
#		is we reach a whitespace character we get a syntax error.
#		a delimiter saves the key and enters value mode (just remove the last
#		N chars from the buffer and voil√°).
#
#Value mode.
#
#	end of file is a syntax error
#	read into the buffer:
#		The delimiter exits to outside mode, saving the value.
#		After exiting to outside mode, the rest of the string is discarded
#		Anything else is added to the string (remove the first N chars
#		from the buffer.
#
#Maybe, after processing a text, we could parse it in pieces, so the 
#substitution is easy, but that can always be arranged later.

#To add a file... we could use add("filelocation.ext"), add({"file1.ext", "file2.ext"}).
#
#Now, the public interface would go like get("yetanother"), which would return
#the string "This is another.".
#
#We could do something like set("varname", "myvar") to permanently 
#translate (:varname:) to "myvar". 
#
#The other part would be something like get("anothertextkey", { {"varname", mystr}, {"varname2", mystr2} })
#which would return anothertextkey's value with the (:varname:) and (:varname2:) 
#replaced with these two strings. This would override the "varname" set 
#with the "set".
#method.
#
#Now, the part that has not been discussed here is the language part... But
#that would be ALMOST accesory... Really. Now that we are it, I'd really like
#a folder base structure like /lan/en or /lan/es and set the language in a 
#root folder like set_root("data/lan"), set_language("en"), so add("myfile.ext")
#would add "data/lan/en/myfile.ext".
#
#Perhaps each file should be added with an unique key, so we can have the same
#text names in different texts... This would change the "add" and "get" 
#methods.
